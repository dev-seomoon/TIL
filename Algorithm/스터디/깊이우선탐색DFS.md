# 깊이우선탐색(depth-first search, DFS)

Reference) https://m.blog.naver.com/kks227/220785731077

## 그래프

- **그래프** : **정점(vertex, 노드), 간선(edge)의 집합**

  - 보통 정점의 집합은 V, 간선의 집합은 E로 나타냄.
  - 정점의 **차수(degree)** : 해당 정점과 이어진 간선의 개수
    - 방향 그래프에서는 차수(degree)를 두 가지(indegree, outdegree)로 나눌 수 있다. indegree는 들어오는 간선의 수, outdegree는 나가는 간선의 수이다.

- 간선에 방향이 있으면 방향 그래프 (화살표 방향으로만 이동할 수 있는 그래프),
  간선에 방향이 없으면 무방향 그래프 (어느 방향으로든 이동할 수 있는 그래프).

- 인접하다(adjacent) : 하나의 정점에서 **간선 하나**를 거쳐서 다른 정점으로 이동할 수 있을 때,
  두 정점이 인접하다고 한다.
  (= 두 정점이 한 간선으로 이어져있을 때)
  무방향 그래프에서는 A, B 정점이 인접하면 B, A도 인접하지만 방향 그래프에서는 한 쪽만 성립한다.

  - 방향그래프에서 양방향을 갖는 간선이 존재할 경우 : 해당 간선을 양쪽 방향으로 나눠서 2개의 간선으로 표현함.

- 싸이클(Cycle) : 간선을 따라 시작한 정점으로 돌아오는 경로

- 가중치 그래프(weighted graph) : 간선들에 가중치가 있는 것.
  비용(weight), 거리(distance) 또는 대역폭(bandwidth, 한 번에 이동 가능한 최대 양)을 의미한다.

  - 방향성을 가지면서 가중치 그래프일 수도 있다.

- 멀티그래프(multigraph) :
  동일한 정점 쌍 A, B 사이에 여러 개의 간선이 존재할 수 있다. 자기 자신에서 출발해서 돌아오는 간선도 존재한다.

## 그래프 순회

- 그래프 순회 : 그래프의 모든 정점을 한 번씩만 방문해보는 것.

- 그래프 순회 방식 :

  - DFS : 한 방향으로 깊게 가다가, 막히면 돌아가서 다른 방향으로 가는 방법.
  - BFS : 여러 방향으로 넓고 얕게 가는 방법.

  어떤 게 더 빠를까?

### DFS 깊이 우선 탐색

1. 정점 하나를 선택
2. 아직 방문하지 않은 인접한 정점 중 하나를 선택해 방문
3. 2번에서 방문한 정점의 아직 방문하지 않은 인접한 정점 중 하나를 선택해 방문
   ... 반복
4. 더 이상 아직 방문하지 않은 인접한 정점이 없다면, 이전 정점으로 돌아감
   ... 반복
5. 더 이상 방문하지 않은 인접한 정점이 없을 때 -> 탐색 종료

- 더 이상 방문할 정점이 없을 때 이전 정점으로 돌아가기 -> **스택**을 사용해 구현.
  - 방문한 정점을 스택에 넣고, 방문이 끝나면 스택에서 꺼내기.
    (+ 재귀 함수도 스택 메모리 구조에 쌓이고 호출되기 때문에, 재귀 함수로도 구현이 가능하다. )

```c++
class Graph {
  int N; // 정점의 개수
  vector<vector<int>> adj; // 인접 정점 리스트 = 간선 리스트
  vector<bool> visited; // 방문 여부를 저장하는 배열


  // 간선 추가 함수
  void addEdge(int u, int v){
    adj[u].push_back(v);
    adj[v].push_back(u);
  }
}

int main(){
  Graph G(6);
  G.addEdge(0, 1);
  G.addEdge(0, 2);
  G.addEdge(1, 3);
  G.addEdge(1, 5);
  G.addEdge(3, 4);
  G.addEdge(4, 5);
  G.sortList();
  G.dfs();
}
```

```c++
void dfs(int curr){
  // 이미 방문한 정점을 다시 방문하지 않기 위해, 방문한 정점을 체크한다.
  visited[curr] = true;
  cout << "node " << curr << " visited" << endl;

  // 각 정점을 방문할 때마다
  // 인접한 정점들 중에서 아직 방문하지 않은 정점을 순차적으로 방문한다.
  for(int next: adj[curr])
    if(!visited[next]) dfs(next);

  // 방문할 곳이 더 없으면 스택에서 그 정점을 빼고 바로 아래 정점 함수로 복귀한다. (함수 호출 스택에서 재귀 함수의 호출 원리와 동일)
  return;
}
```

#### Component (연결 요소)

- Component : 하나의 컴포넌트 안에 속한 정점은 모두 서로 이어져있고,
  다른 컴포넌트의 정점과는 이어져 있지 않다.

- **연결 그래프(connected graph)** : 그래프에 단 하나의 컴포넌트만 존재하는 경우.
  (그래프 안의 모든 정점이 서로 이어진다. )

  - 연결 그래프에서는 DFS를 한 번만 실행해도 모든 정점을 방문할 수 있다.

- **연결 그래프가 아닌 그래프(여러 개의 컴포넌트로 이루어진 그래프)**에서는, DFS를 한 번만 실행하면,
  시작점이 속한 컴포넌트의 정점만 다 방문하고, 나머지는 절대 방문하지 못한다.

  - 그래프 안의 모든 정점을 방문하려면,
    **반복문을 돌면서 방문하지 않은 정점을 볼 때마다 DFS를 시작**해야 한다.
    이 때 **방문을 시도하는 횟수가 컴포넌트의 개수**가 된다.

---

복습)

DFS :

DFS의 탐색(그래프 순회) 방식 :

정점 하나 선택 -> 그 정점의 아직 방문하지 않은 인접한 정점 중 하나를 선택해 방문

A에서 인접한 B를 방문 -> 다음에는 A에 인접한 정점이 아닌 B에 인접한 정점을 방문, ...

더 이상 방문하지 않은 인접한 정점이 없으면,
이전 정점으로 돌아가서 아직 방문하지 않은 인접한 정점을 찾고, 없으면 또 돌아가고, ...
-> 더 이상 남은 방문하지 않은 인접한 정점이 없으면 탐색이 종료됨.

=> "스택"으로 구현.
방문하는 순서대로 정점을 스택에 쌓고, 방문이 끝나면 스택에서 꺼내는 방식.

재귀함수 또한 스택 구조로 호출되기 때문에 재귀함수를 사용해 구현할 수 있다.

DFS의 시간복잡도는 O(V + E) = O(정점의 개수 + 간선의 개수)
한 번 방문한 정점은 다시 방문하지 않고-O(V),
한 정점에서 다음 방문할 노드들을 순회하는 횟수가 그 정점의 차수와 같기 때문-O(E).

이 때 인접리스트가 주어진 경우에는 O(V + E)이지만, 인접행렬만 주어진 경우에는 모든 정점을 순회하며 두 정점이 이어져있는지 확인해야하기 때문에 O(V^2)가 된다.

DFS -> 스택, BFS -> 큐
DFS는 최근에 방문한 노드부터 보는데 (후입선출)
BFS는 먼저 방문한 노드부터 보기 때문 (선입선출)
