# Next.js RFC - 새로운 라우팅 시스템과 Layout의 도입

## 소개

2022년 3월 말 React 18 버전이 릴리스되면서, React에 의존성을 가지는 라이브러리나 프레임워크들은 그에 맞는 변화가 필요해졌다.

리액트 프레임워크인 Next.js도 마찬가지로, Next.js 팀에서는
React 18의 변경사항들을 적극적으로 적용하고자 함.
Next.js 새로운 라우팅 시스템은 리액트 18을 기반으로 함.
이번 Next.js 업데이트는 Next.js가 등장한 2016년 이래로 가장 큰 업데이트가 될 것.ㅊ

아직 정식 출시 예정은 없지만 미리 파악해두기. (\*RFC(Request for Comment)는 올해 5월 말에 나왔다.)

--

1차 RFC : 새롭게 바뀌는 라우팅 시스템과, 그것이 어떻게 리액트 서버 컴포넌트, 데이터 페칭과 연결되는지

2차 RFC : 실제 적용 예시와 구체적인 컨벤션.
그리고 리액트 18의 서스펜스와 부분적인 hydration이 어떻게 적용되는지에 대해.

## 등장 이유

1. 기존 라우팅 시스템과 레이아웃의 한계.

- 레이아웃 생성에 대한 개발자 경험이 향상될 수 있습니다. 중첩이 가능하고 여러 경로에서 공유할 수 있으며 페이지 이동 시 상태를 유지할 수 있는 레이아웃을 쉽게 생성할 수 있어야 합니다.

- 많은 Next.js 애플리케이션은 대시보드 또는 콘솔입니다. 이러한 유형의 애플리케이션에서는 고급 라우팅 솔루션의 이점을 충분히 누릴 수 있습니다.

2. 리액트 18 반영.

리액트의 미래 발전 방향과 함께 하는 라우팅 시스템을 구축하기 위해.

+) 현재 라우팅 시스템도 잘 작동하고 있지만,
더 성능이 좋고 기능이 풍부한 웹 애플리케이션을 쉽게 구축할 수 있도록 하기 위해서.

## 기존 방식

## Memo

### ISR (Incremental Static Regeneration)

사이트 빌드 후에 정적인 페이지를 생성하거나 업데이트할 수 있는 기능.
사이트 전체를 다시 빌드할 필요 없이 페이지별로 정적 생성을 할 수 있어서
정적 생성의 이점과 확장성을 함께 누릴 수 있다.

ISR을 사용하려면 getStaticProps() 메서드에 `revalidate` prop을 추가하면 된다.

```
export async function getStaticProps() {
  const res = await fetch('https://.../posts')
  const posts = await res.json()

  return {
    props: {
      posts,
    },
    revalidate: 10, // In seconds
  }
}
```

위와 같이 설정하면,

페이지에 대한 첫 요청 결과가 캐싱되고

10초가 지난 후에 다음 요청이 실행되면 Next.js가 백그라운드에서 페이지를 재생성한다.

페이지 재생성에 성공하면, 캐싱된 기존 페이지를 invalidate하고
업데이트된 페이지를 보여준다.

백그라운드 요청이 실패해 페이지를 재생성하지 못하면, 기존 페이지를 교체하지 않고 그대로 보여준다.

빌드 타임에 생성되지 않은 path(=getStaticPath() 메서드로 생성되지 않은 path)에 접근하면
Next.js는 첫 요청 시에는 해당 페이지를 서버사이드에서 렌더링하고,
이후 요청에는 캐싱된 정적 파일을 제공한다.

#### On-demand Revalidation :

위에서처럼 revalidate 시간을 설정하는 경우,
캐시를 무효화하고 업데이트된 페이지를 보여주려면 사용자가 방문한 후 일정 시간이 지나야만 하고, 처음에는 모든 사용자가 정적으로 생성된 동일한 페이지를 보게 된다.

Next.js 12.2.0 버전에서부터는
이러한 방식 외에도
수동으로 특정 페이지의 캐시를 지울 수 있는 On-demand ISR을 지원한다.
headless CMS에서 생성되거나 업데이트된 컨텐츠가 있을 때 또는 Ecommerce 메타데이터 변화(가격, 상세설명, 카테고리, 리뷰 등)가 있을 때
사이트를 좀 더 쉽게 업데이트할 수 있다.

On-demand revalidation을 사용하려면 `getStaticProps()` 메서드에 `revalidate` props를 명시하지 않아도 된다.
그러면 `revalidate`가 기본값인 `false`로 설정되고,
`revalidate()` 메서드를 호출했을 때만 on-demand 방식으로 페이지가 revalidate된다.

### 리액트 서버 컴포넌트 (RSC)

#### 서버 컴포넌트란

리액트 18에서 새롭게 등장한 리액트 서버 컴포넌트 (RSC)

리액트 컴포넌트 트리의 일부 컴포넌트를 브라우저가 아닌 서버에서 렌더링할 수 있다.

리액트 서버 컴포넌트 =/= 서버 사이드 렌더링

기존에 모든 리액트 컴포넌트는 브라우저에서 동작하는 "클라이언트 컴포넌트"였다.

서버에서 렌더링을 수행하는 이유 :

- 서버에서는 DB, 파일시스템 등의 데이터 소스에 API 엔드포인트를 거치지 않고 더 직접적으로 접근할 수 있고, 일반적으로 브라우저보다 더 가까운 위치에서 더 빠르게 데이터를 가져올 수 있다.

- 서버에서는 모듈을 더 가볍게 유지할 수 있다. (ex: 브라우저에서 무거운 npm 패키지를 항상 번들로 받은 뒤 사용해야 하는 것과 달리 서버에서는 이러한 의존성을 매번 다운로드할 필요가 없다. )

=> 서버 컴포넌트는 데이터 가져오기, 콘텐츠 렌더링에 집중하고,
클라이언트 컴포넌트는 상태 저장, 상호 작용에 집중함으로써
서버와 브라우저가 각자 가장 잘할 수 있는 일을 하게 한다.
이로 인해 페이지 로드 속도가 빨라지고, 자바스크립트 번들은 작아지며
사용자 경험이 향상될 것이다.

#### 서버 컴포넌트 도입 이유

- 기존 SSR 방식 :

  `ReactDOMServer.renderToString(element)`
  초기 렌더링 결과를 HTML String으로 반환하고, 이를 바탕으로 첫 요청 시 응답으로 HTML 문서를 빠르게 사용자에게 보여준다.

  그리고 클라이언트 단에서 `ReactDOM.hydrate` 함수를 통해 바뀐 부분만 주입해준다.

- 기존 SSR 방식의 한계 :

  - 페이지는 정적으로 export할 수 있지만, 페이지가 아닌 컴포넌트는 정적으로 export할 수가 없다.
    (Next.js: page 컴포넌트가 아니면 SSR 관련함수들(getServerSideProps() 등)을 사용할 수 없음. )
    page 컴포넌트에서 서버에서 fetch해온 데이터를 props를 통해 하위 컴포넌트로 내려주거나, 하위 컴포넌트에서 CSR 방식으로 데이터를 가져와야 했음.

  - UI 렌더링에 필요한 모듈만이 아니라, 데이터 처리에 사용되는 모듈들도 함께 번들링되기 때문에 번들 사이즈가 커져 성능 저하와 네트워크 부담이 커진다. -> 이로 인해 코드 스플리팅이나 lazy loading 같은 기술을 적용해야 하는 것도 불편함으로 작용함.

- 일반적인 컴포넌트 vs RSC :

  - 일반적인 컴포넌트 : 검색창 입력 -> onChange -> 검색 키워드 fetch -> 검색결과 받아와 리액트 컴포넌트 렌더링

  - RSC : 검색창 입력 -> onChange -> 렌더링 서버에 검색 키워드 fetch -> 서버에서 검색 fetch 요청 & 검색 결과 받아서 마크업 빌드해 클라이언트에 전달 -> 클라이언트에서 마크업 받아서 **정적 UI**로 렌더링
    (React 컴포넌트로 렌더링하는 방식 대비 컴포넌트 처리에 드는 시간이 절약됨)

- RSC의 장점 :

  - 서버 컴포넌트는 번들에 포함되지 않기 때문에, 브라우저에서 받아야 하는 번들 사이즈가 현저하게 작아진다. (Zero-Bundle-Size 컴포넌트)

  - API 형식으로 불러올 필요 없이 파일 시스템, DB 등에 직접 접근할 수 있다. (Full Access to the Backend)

  - lazy loading 시 기존에는 React.lazy를 사용해 동적으로 import를 해야 하지만, RSC 사용 시 클라이언트 컴포넌트들은 자동으로 코드 스플리팅이 적용되어, 렌더링이 필요한 시점에 lazy하게 import된다. (Automatic Code Splitting)

  - 렌더링이 끝난 이후에 데이터가 로딩되는 것(waterfall)을 방지할 수 있다.
    RSC를 사용하면 렌더링과 data fetching을 병렬적으로 실행하기 때문에 렌더링이 data fetching을 시작하는 시점에 영향을 주지 않아
    성능이 향상된다. (No Waterfalls)

    - 부모 컴포넌트 -> 자식 컴포넌트로 데이터를 전달하는 구조일 때 waterfall 현상이 더욱 심해진다.
      예를 들어 자식 컴포넌트에서 useEffect 디펜던시로 props를 가질 때, 해당 자식 컴포넌트는 렌더링이 끝나고 부모 컴포넌트에서 전달해주는 props가 전부 로딩된 후에야 data fetching을 시작하게 된다. 그 동안 UI는 계속 로딩 상태여야한다.
    - 이는 리액트에서 최근에 도입하려고 하는 Concurrent Mode, Suspense와도 연관된 문제이다.

https://programming119.tistory.com/252

#### 서버 컴포넌트 사용 방법

파일 확장자 기반으로 서버 컴포넌트와 클라이언트 컴포넌트 구별.
(`.server.jsx`, `client.jsx`)
사람은 물론 번들러에서도 서버 컴포넌트와 클라이언트 컴포넌트를 구별해 다룰 수 있게 된다.
(번들러는 RSC가 동작하는 데 중요한 역할을 함. )

서버 컴포넌트에는 브라우저에서 실행, 작동할 수 없는 코드가 있을 수 있기 때문에
클라이언트 컴포넌트에서 서버 컴포넌트를 가져오거나 렌더링할 수는 없다.

대신, 합성(composition)해서 사용할 수는 있다.
클라이언트 컴포넌트의 children prop으로 서버 컴포넌트를 전달하는 방식이다.
클라이언트 컴포넌트에서 서버 컴포넌트를 ReactNode 타입의 prop으로 받아와 렌더링할 수 있게 된다.

(추측: 서버 컴포넌트를 렌더링해서 html 엘리먼트로 변환한 후에 클라이언트 컴포넌트의 ReactNode prop으로 전달되어 렌더링되는 걸까?)

#### 서버 컴포넌트 렌더링 & 생명주기

1. 서버에서 렌더링 요청을 받는다.

   RSC를 사용하는 페이지의 라이프사이클은 항상 서버에서부터 시작한다.
   (즉, 리액트 컴포넌트를 렌더링하는 데 필요한 API 호출에 대해 서버가 응답하는 것으로 시작한다.)
   페이지의 루트 컴포넌트는 항상 서버 컴포넌트이기 때문에, 다른 서버나 클라이언트 컴포넌트를 렌더링할 수 있다.

   서버는 요청을 기반으로 어떤 서버 컴포넌트가 있는지, 어떤 props를 사용하는지 확인한다.

2. 서버에서 루트 컴포넌트를 JSON으로 변환한다.

   - 루트 서버 컴포넌트를 html 태그 트리로 렌더링하고, 클라이언트 컴포넌트가 들어갈 부분을 placeholder로 채운다.
   - 그런 다음 이 트리를 serialize(직렬화, 객체->문자열로 인코딩하는 것)해서 JSON 문자열로 만들고 이것을 브라우저에 보내면,
   - 브라우저에서는 이 JSON 문자열을 deserialize(역직렬화, JSON문자열 -> 객체로)하여 클라이언트 placeholder를 실제 클라이언트 컴포넌트로 채우고
   - 최종 결과를 렌더링한다.

   - 컴포넌트 트리(객체)를 JSON 문자열로 serialize하려면
     먼저 `resolveModelToJSON()` 메서드를 사용한 결과를 `JSON.stringify()`에 전달해야 한다.
     (리액트 엘리먼트는 type 필드가 문자열 또는 함수(컴포넌트 인스턴스)인 객체로, type 필드가 문자열이 아닌 컴포넌트 함수를 참조하고 있는 경우 JSON 직렬화가 불가능하므로 `JSON.stringify()`에 전달하기 전에 `resolveModelToJSON()`을 거쳐야 한다. )

     `resolveModelToJSON()` 내부적으로는 인자로 전달받은 리액트 엘리먼트에 대해 다음과 같이 동작한다.

     - html 태그인 경우 이미 직렬화가 가능하기 때문에 특별히 할 일이 없다.
     - 서버 컴포넌트인 경우 컴포넌트 함수를 호출한 결과를 직렬화한다. (모든 서버 컴포넌트를 일반 html 태그로 변환해 렌더링할 수 있도록 하는 것이 목표이다. )
     - 클라이언트 컴포넌트인 경우 함수가 아닌 모듈 참조 객체 형태이기 때문에 마찬가지로 이미 직렬화가 가능한 상태이다.

     **모듈 참조 객체란?**
     RSC를 도입하면서 React 엘리먼트의 `type` 필드에 컴포넌트 함수 대신 모듈 참조를 담을 수 있게 된다.
     모듈 참조는 컴포넌트 함수에 대한 참조로, 직렬화가 가능하다.

     클라이언트 컴포넌트 함수를 직렬화 가능한 모듈 참조 객체로 변환하는 일은 번들러에서 수행된다.
     리액트는 웹팩 로더인 `react-server-dom-webpack` 출시해 RSC를 공식적으로 지원한다.

- 위와 같은 과정을 거쳐 최종적으로 리액트 컴포넌트 트리 전체가 JSON으로 직렬화 가능한 상태로 변환되어야 한다. 서버 컴포넌트는 html 태그로, 클라이언트 컴포넌트는 placeholder로 변환되며,
  이 때 컴포넌트에 전달되는 모든 props도 마찬가지로 직렬화 가능해야 한다.
  따라서 서버 컴포넌트에 이벤트 핸들러 등의 함수를 props로 전달할 수 없다.

3. 브라우저가 서버에서 받은 JSON을 리액트 트리로 deserialize한다.

브라우저에서는 서버에서 받은 JSON 문자열을 렌더링하기 위해 리액트 트리로 변환하는 과정을 거친다.
이 때 번들러를 사용해 type이 모듈 참조인 엘리먼트를 실제 클라이언트 컴포넌트 함수에 대한 참조로 대체한다.

#### RSC Wire 포맷

#### RSC를 메타 프레임워크와 함께 사용해야 하는 이유

RSC는 일반 리액트 프로젝트보다는 Next.js 등 메타 프레임워크에서 사용될 것이다.
메타 프레임워크는 추상화를 제공하고, 서버 사이드 렌더링도 지원하며
서버 컴포넌트를 사용하는 경우 서버에서 생성한 html을 hydrate하는 작업도 수행할 수 있기 때문이다.

---

공부할 키워드

hydrate

---

Reference)

- https://programming119.tistory.com/267
- [Next.js 12 업데이트](https://programming119.tistory.com/255?category=887784)
