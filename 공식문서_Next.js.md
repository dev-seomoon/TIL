# Next.js

## 1. 기초

### 1) Next.js란

빠른 Web Application을 만들기 위한 구성 요소들을 제공하는 React 프레임워크

- Web Application의 구성 요소 :
  UI, 라우팅, Data fetching, 렌더링, 서드파티 서비스 통합, 성능, 확장성, 유지보수성

- React는 자바스크립트 UI 라이브러리.
  UI 구성을 위한 함수들을 제공하지만, 함수를 어디에서 어떻게 사용할지는 개발자의 선택에 맡긴다.
  UI 외의 요소들은 개발자가 직접 구성해나가야 하기 때문에 시간이 다소 소요된다.

- Next.js는 React에 필요한 툴이나 설정을 제공하고, 최적화 등 추가적인 기능을 제공한다.

### 2) JavaScript -> React

#### JavaScript, UI 렌더링 과정

- 브라우저가 동적인 UI를 생성하는 과정 (브라우저의 렌더링 과정) :

  - 유저가 웹 페이지에 접속하면, 서버가 브라우저에 HTML 파일을 응답한다.
  - 브라우저는 HTML 파일을 읽고 DOM을 생성한다.
  - DOM은 HTML 엘리먼트들을 객체로 나타낸 것. 코드와 UI 사이의 브릿지 역할을 하며, 부모 자식 관계로 이루어진 트리 구조를 갖는다.
  - DOM 메소드나 JavaScript를 사용해 유저 이벤트를 listen하고 DOM을 조작할 수 있다.
    엘리먼트 선택/추가/삭제 뿐만 아니라 엘리먼트의 스타일이나 컨텐츠 변경도 가능하다.

- 그러나, DOM 메소드와 JavaScript만으로 DOM을 조작하려면,
  앱의 규모가 커졌을 때 코드양이 너무 많아져 유지보수가 어려워질 수 있다.
  이는 전형적인 절차형 프로그래밍 방식이다.

- 선언형 UI 라이브러리인 React를 사용해 "how"가 아닌 "what"에 집중하여 코드를 작성함으로써 개발 속도를 높일 수 있다.

- JavaScript -> React === (**how**, 절차형 프로그래밍) -> (**what**, 선언형 프로그래밍)

#### React

- 프로젝트에서 React를 사용하려면
  react(리액트 코어 라이브러리)와 react-dom(리액트로 dom을 조작할 수 있도록 해주는 라이브러리) 패키지를 설치해야 한다.

- JSX : HTML과 비슷한 문법을 사용해서 UI를 선언할 수 있는 자바스크립트 확장 문법.
  브라우저는 JSX를 이해하지 못하므로, Babel 등의 JavaScript 컴파일러를 사용해 JSX를 일반 JavaScript 코드로 변환(컴파일)해야 한다.

- React는 특정한 기능을 제공하는 재사용가능한 코드 조각들을 제공하는 라이브러리이다.

- **컴포넌트를 사용해서 UI 구현하기** :
  컴포넌트 단위로 UI를 모듈화하여 유지보수성을 높일 수 있다.

  - 리액트 컴포넌트는 UI 엘리먼트를 반환하는 JavaScript 함수이다.
  - 컴포넌트를 DOM에 렌더링하려면, `ReactDOM.render()` 메소드의 첫 번째 인자로 전달해야 한다.
    리액트 컴포넌트 이름은 대문자로 시작해야 하고, `<>`으로 감싸서 전달해야 한다.
  - 일반 HTML 엘리먼트처럼 컴포넌트를 중첩시킬 수 있다.

- **Props** :
  컴포넌트에 정보를 전달하기 위해 사용한다.

  - 동일한 컴포넌트에 각각 다른 데이터를 전달하고 싶거나,
    컴포넌트에 들어갈 데이터를 미리 알 수 없는 경우 (ex: 외부 소스에서 데이터를 가져오는 경우)
    "Props"를 사용해 리액트 컴포넌트에 프로퍼티 형태로 데이터를 전달할 수 있다.
    프로퍼티 형태로 전달된 데이터는 컴포넌트의 첫 번째 인자에 props 객체로 전달된다.
  - 리액트는 단방향 데이터 흐름을 갖는다. props와 state는 부모 컴포넌트에서 자식 컴포넌트로만 전달될 수 있다.
  - JSX 안에서 JavaScript 코드를 작성하려면, `{}` 안에 작성해야 한다. 어떤 자바스크립트 표현식이든 작성할 수 있다.
  - 리스트 형태로 보여주어야 하는 데이터가 있는 경우,
    배열 메소드를 사용해 데이터를 조작하고 UI 엘리먼트를 생성할 수 있다.
    리스트를 렌더링 하는 경우, 리스트의 각 요소에 유니크한 키값을 prop으로 전달해야 한다.

- **State와 Event handler** :

  - 이벤트 & 이벤트 핸들러 :
    리액트에서 이벤트 이름은 camelCase로 작성한다.
    이벤트에 이벤트 핸들러 함수를 전달해
    이벤트 발생 시 핸들러 함수가 호출되게 할 수 있다.

  - hooks :
    리액트는 hooks를 가지고 있다. hooks는 함수들을 모아둔 것으로, hooks를 사용해 컴포넌트에 **state**와 같은 로직을 추가할 수 있다.
    (ex: `useState()`)
    state는 UI에서 시간에 따라 바뀌는(주로 유저 상호작용에 의해 변경되는) 데이터를 담는 데 사용한다.

  - state는 컴포넌트 내부에서 초기화되고 저장된다. state를 자식 컴포넌트에 props로 넘길 수는 있지만, state를 업데이트하는 로직은 state가 초기화된 컴포넌트에 있어야 한다.

  - props vs state :
    props는 컴포넌트에 전달되는 read-only 데이터,
    state는 시간에 따라 변하는 데이터.

### 3) React ~ Next.js

- Node.js를 설치하고 프로젝트 루트에 `package.json` 파일을 생성한다.

- react, react-dom, next 패키지를 추가한다.

- pages 폴더 안에 `index.js` 파일을 작성하고,
  각 페이지의 루트 컴포넌트는 export default를 한다.

- Fast Refresh : 코드 수정 후 저장 시 변경사항이 즉시 반영됨

### 4) Next.js 내부 동작 방식

- React는 애플리케이션 구조와 구현 방식에 대해 자유도가 높기 때문에, 다양한 방식으로 구현할 수 있다.
  Next.js는 애플리케이션 구조와 최적화를 제공하는 프레임워크로, 개발 속도와 애플리케이션 속도를 모두 향상시킬 수 있다.

#### 개발 환경 vs 프로덕션 환경

- 개발 환경 : 개발 경험을 향상시키는데 초점을 맞춤. (TypeScript, ESLint, Fast Refresh 등)
- 프로덕션 환경 : 사용자 경험 향상에 초점을 맞춤. (성능, 접근성 최적화 등)

- 애플리케이션이 개발 단계 -> 프로덕션 단계로 가기 위해서는,
  컴파일, 번들링, 압축, 코드 스플릿 과정을 거쳐야 한다.
  Next.js는 이러한 대부분의 과정을 쉽게 수행할 수 있게 해준다.

- Next.js는 저레벨 프로그래밍 언어인 Rust로 작성된 컴파일러와,
  컴파일, 압축, 번들링 등에 사용할 수 있는 플랫폼인 SWC를 가지고 있다.

##### 1 - 컴파일

- 컴파일은 한 언어를 다른 언어로 변환하거나, 해당 언어의 다른 버전으로 변환하는 것을 말한다.
  JSX, TypeScript, 모던 자바스크립트 등의 언어들은 개발할 때 효율성과 편리성을 향상시켜주지만, 브라우저가 이해하지 못하기 때문에, 일반 JavaScript로 컴파일되어야 한다.

- Next.js에서는, 개발 단계에서 코드를 수정할 때 컴파일이 일어나고, 애플리케이션 프로덕션을 준비하는 빌드 과정에도 컴파일이 일어난다.

##### 2 - 압축 (Minifying)

- 코드 가독성을 위해서만 필요하고, 코드 실행에는 불필요한 요소들 (주석, 공백, 줄바꿈, 들여쓰기 등)을 제거해서
  파일 사이즈를 줄여 애플리케이션 속도를 향상시키는 과정.

- Next.js에서는 js, css 파일이 빌드 중에 자동으로 압축된다.

##### 3 - 번들링

- 유저가 웹 페이지에 방문했을 때 파일 요청 횟수를 줄이기 위해서,
  모듈화되어 작성된 애플리케이션의 파일들(모듈들)을 모듈 디펜던시를 따라 병합하는 과정.

##### 4 - 코드 스플리팅

- 애플리케이션 번들을 엔트리 포인트별로 쪼개는 과정.
  현재 접속한 페이지의 코드만 로드해서
  애플리케이션의 초기 로딩 속도를 줄이기 위함.
  (Only load the required code for an entry point, to improve the application's initial load)

- Next.js는 코드 스플리팅 기능을 기본적으로 지원한다.
  - `pages/` 폴더에 있는 각 파일들은 빌드 단계에 자동으로
    별도의 번들로 나눠진다.
  - 두 개 이상의 페이지에서 공유하는 코드는, 중복 다운로드를 피하기 위해 별도의 번들로 분리된다.
  - 첫 페이지를 로드한 후에는, 유저가 접속할 가능성이 높은 다른 페이지들의 코드도 미리 로드한다.
  - Dynamic Imports를 통해 수동으로 코드 스플리팅을 수행할 수도 있다.

#### 빌드 타임 vs 런타임

- 빌드 타임 : 애플리케이션 배포를 준비하는 과정.
  앱을 빌드하면, Next.js는 코드를 프로덕션에 최적화된 파일들로 변환해 서버에 배포하고 유저가 사용할 수 있는 상태가 되게 한다.

- 런타임 : 앱이 빌드되고 배포된 후에, 유저가 앱을 사용할 때를 런타임이라고 한다.

#### 클라이언트 사이드 렌더링 vs 서버 사이드 렌더링

- 클라이언트 : 유저 디바이스의 브라우저. 서버에 애플리케이션 코드에 대한 요청을 보내고,
  응답을 받아서 유저가 상호작용할 수 있는 인터페이스로
  유저에게 돌려준다.

- 서버 : 애플리케이션 코드를 저장하고, 클라이언트로부터 요청을 받고, 연산을 하고 적절한 응답을 돌려 보내는 데이터 센터의 컴퓨터를 말한다.

- 렌더링 : React로 작성한 코드를 UI를 표현하는 HTML로 변환하기 위해 필수적인 과정.
  렌더링은 서버에서 일어날 수도 있고, 클라이언트에서 일어날 수도 있다.
  빌드 시 미리 렌더링을 하거나, (pre-rendering)
  런타임 시 요청할 때마다 렌더링을 할 수도 있다.
  Next.js에서는 세 가지 렌더링 방식(**서버 사이드 렌더링, 정적 사이트 생성, 클라이언트 사이드 렌더링**)을 제공한다.

  - **Pre-Rendering** : 서버 사이드 렌더링, 정적 사이트 생성 방식은 Pre-rendering이라고도 한다.
    외부 데이터 fetching과,
    리액트 컴포넌트 -> HTML 변환이 끝난 후에,
    결과가 클라이언트에 전달되기 때문이다.

  - **클라이언트 사이드 렌더링 vs Pre-Rendering** :

    - 일반적인 React 앱에서 브라우저는
      UI 구성을 위한 JS와 함께 빈 HTML 껍데기를 받는다.
      초기 렌더링이 클라이언트 측에서 일어나기 때문에, 이를 클라이언트 사이드 렌더링이라고 부른다.

    - React 앱이 클라이언트 사이드 렌더링을 하는 것과는 다르게,
      Next.js 앱은 기본적으로 모든 페이지를 pre-rendering한다.
      pre-rendering은 클라이언트에서 자바스크립트로 HTML을 생성하는 대신, 서버에서 HTML이 미리 생성되는 것을 말한다.

    - 클라이언트 사이드 렌더링을 할 경우,
      렌더링이 수행되는 동안 유저가 빈 화면을 보게 되는 반면,
      프리 렌더링을 하면 생성된 HTML을 보게 된다.

    +) Next.js 앱에서는
    React의 `useEffect()`로 데이터를 fetch하거나, useSWR과 같은 data fetching hook을 사용해서
    특정 컴포넌트에서 선택적으로 클라이언트 사이드 렌더링을 할 수 있다.

  - **서버 사이드 렌더링 vs 정적 사이트 생성** :
    프리 렌더링에는 서버 사이드 렌더링과 정적 사이트 생성 두 가지가 있다.

    - 서버 사이드 렌더링 :
      서버 사이드 렌더링을 하면, 요청을 할 때마다 서버에서 페이지의 HTML이 생성된다.
      HTML이 생성된 후에 HTML, JSON 데이터, JavaScript가 클라이언트로 보내진다.

      클라이언트에서, HTML은
      React가 JSON 데이터와 JavaScript 코드를 사용해서 컴포넌트를 동적으로 만드는 동안 (ex: 버튼에 이벤트 핸들러를 다는 것)
      유저에게 정적인 페이지를 빠르게 보여주는 데 사용된다.
      React에서 컴포넌트를 동적으로 만드는 작업을 **hydration**(주입)이라고 한다.

      Next.js에서는 `getServerSideProps`를 사용해서 페이지를 서버 사이드 렌더링할 수 있다.

    - 정적 사이트 생성 :
      서버에서 HTML이 생성되는 건 서버 사이드 렌더링과 동일하지만,
      정적 사이트 생성은 런타임에 서버가 돌아가지 않는다.
      대신 애플리케이션이 배포될 때 빌드 타임에 컨텐츠가 한 번 생성되고나서, HTML이 CDN에 저장되고 요청 때마다 재사용된다.

      Next.js에서는 `getStaticProps`를 사용해 정적으로 페이지를 생성할 수 있다.

      데이터가 바뀔 때마다 사이트 전체를 다시 빌드할 필요 없이, Incremental Static Regeneration을 통해 빌드된 페이지를 생성하거나 업데이트할 수 있다.

- Next.js를 사용하면, 페이지별로 가장 적절한 렌더링 메소드를 적용할 수 있다.

#### CDNs and the Edge

앱이 네트워크에 배포된 후에, 어디에 앱 코드가 저장되고 실행되는지 알아보자.
(\*네트워크 = 자원을 공유할 수 있는 연결된 컴퓨터들(또는 서버들))

Next.js 앱의 경우 애플리케이션 코드가 **Origin Server, CDNs(Content Delivery Networks), the Edge**에 저장된다.

##### Origin Server

Origin 서버는 애플리케이션 코드를 저장하고 실행하는 메인 컴퓨터를 말한다.
(CDN 서버, Edge 서버 등 애플리케이션 코드가 배포되는 다른 서버와 비교하기 위해 Origin 서버라고 표현함)

Origin 서버가 요청을 받으면, 응답을 보내기 전에 약간의 연산을 한다.
이 연산 작업의 결과는 CDN으로 옮겨진다.

##### CDN (Content Delivery Network)

- CDN은 전세계의 여러 장소에 HTML, 이미지 파일 등 정적 콘텐츠를 저장하며, 클라이언트와 origin 서버 사이에 위치한다.

- 새로운 요청이 들어오면 유저에게 가장 가까운 위치의 CDN에서 캐싱된 결과를 유저에게 응답한다.
  연산이 매 요청마다 일어나지 않아서 origin 서버의 부하를 줄일 수 있고,
  유저에게 지리적으로 가까운 곳에서 응답이 오기 때문에
  응답 속도도 좀 더 빨라진다.

- Next.js의 pre-rendering으로 생성된 컨텐츠를 저장하기에 적합하다.

##### The Edge

## 첫 앱 만들기

## 검색엔진 최적화

## TypeScript
